[{"content":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服务并未正常运行，执行systemctl --user status someService显示服务为active，并没有错误信息。重新尝试后仍然存在问题,客户端出现 502 Bad Gateway 错误，遂进行问题定位。\n定位问题 相关配置 因为仅是部分服务迁移到容器，原本的 Nginx 服务并没有变动，相关配置为\nlocation /somePath { proxy_redirect off; proxy_pass http://127.0.0.1:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $http_host; } 容器使用 Podman 在普通用户下运行，执行参数为\n-p 8000:3000 -v ./someDir/:/etc/some/config/:rw 服务本声也并没有变动，相关配置与数据也维持原样并进行映射。\n错误信息 客户端查看 log 后发现报错：\nFailed to dial to wss://someSite/somePath 502 Bad Gateway websocket: bad handshake 但没有额外信息，初步判断为 Nginx 无法连通子服务，从而产生 502 Bad Gateway 错误。\n问题排查  测试确认 Nginx 能够正常运行，其他路径下非容器内的服务都正常运行 在同参数下运行podman run busybox ls -al，确认配置文件与数据能被 container 正常获取 host 下直接连接 container 的 WebSocket，失败，显示 502 systemctl --user status显示 container 正常运行  于是缩小了问题范围，应该是容器化后的网络映射导致了问题。\n解决问题 查阅 podman 文档1,在 podman run 的文档中找到 --publish 与--network的说明。其中列出了网络模式：\n Valid mode values are:\n bridge[:OPTIONS,…]: Create a network stack on the default bridge. This is the default for rootfull containers. It is possible to specify these additional options: For example to set a static ipv4 address and a static mac address, use \u0026ndash;network bridge:ip=10.88.0.10,mac=44:33:22:11:00:99. [:OPTIONS,…]: Connect to a user-defined network; this is the network name or ID from a network created by podman network create. Using the network name implies the bridge network mode. It is possible to specify the same options described under the bridge mode above. You can use the \u0026ndash;network option multiple times to specify additional networks. none: Create a network namespace for the container but do not configure network interfaces for it, thus the container has no network connectivity. container:id: Reuse another container’s network stack. host: Do not create a network namespace, the container will use the host’s network. Note: The host mode gives the container full access to local system services such as D-bus and is therefore considered insecure. ns:path: Path to a network namespace to join. private: Create a new namespace for the container. This will use the bridge mode for rootfull containers and slirp4netns for rootless ones. slirp4netns[:OPTIONS,…]: use slirp4netns(1) to create a user network stack. This is the default for rootless containers. It is possible to specify these additional options:   并且检索后找到 stackoverflow 上的一个回答2，指出容器化会创建 network namespace，所以容器内部获取的 localhost 并非 host 下的 localhost，从而导致容器内服务不能正常运行。\n通过设置--net=host运行容器，或修改 Nginx 中proxy_pass的配置指向实际的 host 网络，就可以解决 502 的问题。\n一些延伸 使用--net=host参数是最简便的解决方法，但直接使用 host 网络会导致 port 冲突，造成多 container 场景下的部署问题。对容器网络进行配置的方式应该是更好的，但对于简单场景来说有些不必要，以后有机会也可以尝试一下。\n单机使用容器也是抱着尝试的心态，看看是否能简化服务的管理。使用过程中发现对容器相关的 cgroup、网络等问题还不够熟悉，就先记录下来，后续有时间时可以学习一下相关知识。\n  https://docs.podman.io/en/latest/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://stackoverflow.com/questions/38346847/nginx-docker-container-502-bad-gateway-response\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/container.websocket.502/","summary":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服","title":"端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误"},{"content":"前言 一次调试时，发现 Firefox 中可以通过 boolean 值来使用 Array.sort()，而在 Node.js 中仅能使用 number 类型。尽管这个问题没有造成代码错误，但还是会造成一些困惑。\nJS 引擎间差异 简单运行下测试代码，结果如下：\n Firefox  const arr = [{num:1}, {num:3}, {num:2}] const numSorted = arr.sort((a, b) =\u0026gt; a.num - b.num) console.log(numSorted) \u0026gt; Array [Object { num: 1 }, Object { num: 2 }, Object { num: 3 }] const arr = [{num:1}, {num:3}, {num:2}] const boolSorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(boolSorted) \u0026gt; Array [Object { num: 1 }, Object { num: 2 }, Object { num: 3 }]  Node.js  const arr = [{num:1}, {num:3}, {num:2}] const sorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(sorted) \u0026gt; [ { num: 1 }, { num: 3 }, { num: 2 } ]  Deno  const arr = [{num:1}, {num:3}, {num:2}] const sorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(sorted) \u0026gt; [ { num: 1 }, { num: 3 }, { num: 2 } ] 可以发现，Node 与 Deno 同样使用 V8 引擎，仅能在 Array.sort()中使用 number 类型作为判断，而 Firefox 中能够使用 number 或 boolean 值作为判断。\nTypeScript 中 Array.sort()的类型 在 TypeScript 中 Array.sort()的类型为\n(method) Array\u0026lt;T\u0026gt;.sort(compareFn?: ((a: T, b: T) =\u0026gt; number) | undefined): T[] 尝试使用 boolean 类型的 sort(),但 TS 报出类型错误:\nArgument of type \u0026#39;(a: { num: number; }, b: { num: number; }) =\u0026gt; boolean\u0026#39; is not assignable to parameter of type \u0026#39;(a: { num: number; }, b: { num: number; }) =\u0026gt; number\u0026#39;. Type \u0026#39;boolean\u0026#39; is not assignable to type \u0026#39;number\u0026#39;.ts(2345) MDN 文档与 ECMA 标准 查阅 MDN 文档1，\n So, the compare function has the following form:\nfunction compare(a, b) { if (a is less than b by some ordering criterion) { return -1; } if (a is greater than b by the ordering criterion) { return 1; } // a must be equal to b return 0; }  说明中并未标明可以使用 boolean 值，继续查阅 ECMA 文档2,\n  If x and y are both undefined, return +0𝔽. If x is undefined, return 1𝔽. If y is undefined, return -1𝔽. If comparefn is not undefined, then  Let v be ? ToNumber(? Call(comparefn, undefined, « x, y »)). If v is NaN, return +0𝔽. Return v.   Let xString be ? ToString(x). Let yString be ? ToString(y). Let xSmaller be ! IsLessThan(xString, yString, true). If xSmaller is true, return -1𝔽. Let ySmaller be ! IsLessThan(yString, xString, true). If ySmaller is true, return 1𝔽. Return +0𝔽.   标准中同样也未指出可以使用 boolean 值进行判断。\n总结 Firefox 中能够使用 boolean 值进行判断，可能是 Firefox 的实现问题，在相关文档与标准中并没有相关说明。实际写代码时，在 lint 工具等约束后应该并不会产生异常问题，仅是出于好奇进行了一些检索，简单记录一下。\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.sort\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/firefox.sort.by.boolean/","summary":"前言 一次调试时，发现 Firefox 中可以通过 boolean 值来使用 Array.sort()，而在 Node.js 中仅能使用 number 类型。尽管这个问题没有造成代码错误，但还是会造成一些困","title":"Firefox 中 Array.sort() 能够使用 boolean 值进行判断"},{"content":"Hello world 突然萌生了一个念头，想着可以写写博客，简单地记录一点平时的所见所思。\n近来看过的东西不少，积累下来的却不多。博客也就权当是备忘录了，写一写，记一记，兴许能多积累些。即便没什么获益，以后再看，也算是一些回忆了。\n以此自勉。\n","permalink":"https://jasondg.github.io/posts/0/","summary":"\u003ch1 id=\"hello-world\"\u003eHello world\u003c/h1\u003e","title":"0"}]