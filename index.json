[{"content":"问题与解决方案 一般情况 一次在 React 中进行 canvas 开发时，发现 canvas 的 onKeyDown 无法生效。\n刚开始不清楚是否是 event delegate 的问题，在 canvas 上绑定 onClick，测试能够正常触发事件。\n检索后找到了 Stack Overflow 上的一个回答，其中提到 canvas 默认无法被 focus，所以无法绑定键盘事件。\n其给出的解决方案很简单\n\u0026lt;canvas tabindex=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; tabindex使 canvas 能够被 focus，从而能正常监听键盘事件。\n第三方库创建的 canvas 添加tabindex的方式虽然很简洁，但对于第三方库创建的 canvas 而言，直接修改仍然存在问题。如果第三方库没有提供相应功能，尽管通过 DOM 方法能够修改 canvas 的属性，侵入式的修改也可能造成潜在问题。\n在 canvas 不能直接控制的情况下，可以在document.body上绑定keydown事件，并关联相应的处理逻辑。这种方式使用了全局对象，在较大的项目中会增加维护成本。\n另一种方式是通过 canvas 绑定鼠标/触控事件，产生交互时设置 canvas 的外层可控 element 为焦点，并在外层 element 上监听键盘事件。这种方式增加了一些复杂度，不过能更好地约束作用域。\n多 canvas 交互 同一页面存在多个 canvas 需要监听键盘事件时，如之前部分所说，一种方式是，在使用document.body监听的情况下，记录一个全局的 LRU 列表或最新指向的引用/指针，每次 canvas 有交互时记录最新的指向，从而执行相应 canvas 的处理逻辑。\n而使用另一种方式，即切换 focus 至外层时，多个 canvas 的交互并不互相干扰，这也是此种方式的一个优势。\n一些拓展 activeElement 可以使用document.activeElement获得当前的 focus 对象，便于调试1。\nfocus steps 因为好奇 canvas 的 focus 为什么不会冒泡至 parent element，检索了 whatwg 上关于 focus 的部分2，根据 focus 的获取步骤，focus 仅会向内部寻找 focusable area，而不会像事件那样向上冒泡。当 focus 失败时就会返回 document 作为 focus 对象。\n  https://html.spec.whatwg.org/multipage/interaction.html#focus-management-apis\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://html.spec.whatwg.org/multipage/interaction.html#focusing-steps\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/use.keyboard.event.in.canvas/","summary":"问题与解决方案 一般情况 一次在 React 中进行 canvas 开发时，发现 canvas 的 onKeyDown 无法生效。 刚开始不清楚是否是 event delegate 的问题，在 canvas 上绑定 onClick，测试能够正常触发事","title":"在 canvas 中监听键盘事件"},{"content":"为什么需要 Monorepo 在开发中，功能模块间的耦合会导致项目难以维护，因此需要分包来进行解耦合。\n但是单纯地进行分包，就需要单独发布，单独安装，会增加一些繁琐的步骤。并且，快速迭代开发时，一个包需要依赖其他的包的最新修改，此时，因为需要操作相关包发布更新，开发效率会有一定降低。\n而 Monorepo 将所有包都放置于同一个项目内，在分包的前提下通过直接链接本地依赖，解决了等待更新的问题。\n如何创建 Monorepo 以下操作使用 pnpm 作为包管理器，如果还未安装，可以参见 通过 corepack 使用 pnpm 与 yarn 作为包管理器 进行 pnpm 的启用。\n首先在项目根目录下创建pnpm-workspace.yaml文件，添加需要作为 workspace 的目录项，例如 pnpm 的官方示例1：\npackages: # all packages in subdirs of packages/ and components/ - \u0026#39;packages/**\u0026#39; - \u0026#39;components/**\u0026#39; # exclude packages that are inside test directories - \u0026#39;!**/test/**\u0026#39; 同时新建 workspace 的文件夹，\n/packages /someWorkspace /web /... 之后就可以进行依赖的添加。如果需要在项目全局进行安装，需要添加-w参数，而如果在 workspace 内进行安装，需要添加--filter \u0026lt;workspace\u0026gt;参数，同时可以使用-r参数为所有包添加依赖，例如：\n// install to monorepo pnpm add react -w // install to workspace pnpm add react --filter @project/someWorkspace // install recursively pnpm add react -r 如果需要依赖其他 workspace，可以执行\npnpm add @project/someWorkspace --filter @project/web pnpm 会自动处理为 workspace 依赖，例如：\n{ \u0026#34;dependencies\u0026#34;: { \u0026#34;@project/someWorkspace\u0026#34;: \u0026#34;workspace:^1.0.0\u0026#34; } } 并且在发布时会替换为正确的依赖项。\n同理，package.json 中的 scripts 也是类似的配置：\n// monorepo { \u0026#34;scripts\u0026#34;: { \u0026#34;dev:web\u0026#34;: \u0026#34;pnpm dev --filter @project/web\u0026#34; } } // workspace (@project/web) { \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;start dev server\u0026#34; } } 这样就建立了基本的 Monorepo 项目。\n如果使用的是 yarn，可以参见官方文档。\n选择 pnpm 主要是因为 pnpm 的实现方式更直接，且其在个人开发环境下对硬盘更友好，安装速度会有一定的提升。如果是组织协作等场景，还需要视具体情况选择包管理器。\n遇到的问题 使用 TypeScript 在 Monorepo 中使用 TypeScript 时，会在 import 时提示\nCannot find module '@project/someWorkspace' or its corresponding type declarations.ts(2307)  因此需要进行tsconfig.json的配置，添加相应 workspace 的 paths，例如：\n{ \u0026#34;compilerOptions\u0026#34;: { ... \u0026#34;paths\u0026#34;: { \u0026#34;@project/web\u0026#34;: [\u0026#34;./packages/web/src\u0026#34;], \u0026#34;@project/someWorkspace\u0026#34;: [\u0026#34;./packages/someWorkspace/src\u0026#34;] } } } 使用 ESLint 在 Monorepo 中使用 ESLint 与 eslint-plugin-import / eslint-import-resolver-typescript 时，会在 import 时提示\nUnable to resolve path to module '@project/someWorkspace'. eslint(import/no-unresolved)  因此需要进行.eslintrc.json的配置，禁用相应的规则\n{ \u0026#34;rules\u0026#34;: { \u0026#34;import/no-unresolved\u0026#34;: 0 } } 这个问题也有一些讨论2345，但尝试后发现，最直接的解决方法就是禁用import/no-unresolved规则。因为 TypeScript 也会检查import语句，所以目前看还未造成太大问题。\n工程管理粒度 Monorepo 方式会将所有包置于一个项目中，对其中一个包的修改也需要满足整体项目的管理要求。\n一方面，这强化了工程管理，对各个包的管理更为紧密，使得整个项目可维护性更高；另一方面，这也增加了管理成本，丧失了一些灵活性。\n总结 使用 Monorepo 方式建立项目，能够更好地进行分包管理，降低项目中多个模块之间的耦合度，同时避免单独分包的繁琐操作，提高迭代效率。但同时也会增加管理成本，降低一些灵活性。\n因此，需要根据实际情况选择是否使用 Monorepo。而在合适的情况下，Monorepo 是很值得尝试的，尽管目前可能遇到一些小问题，但相信随着技术完善，更多的 corner cases 会被覆盖。\n  https://pnpm.io/pnpm-workspace_yaml\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/import-js/eslint-plugin-import/issues/2247\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/alexgorbatchev/eslint-import-resolver-typescript/issues/45\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/alexgorbatchev/eslint-import-resolver-typescript/issues/36\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://stackoverflow.com/questions/69932369/setting-up-eslint-import-resolver-typescript-in-monorepo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/create.monorepo.using.pnpm/","summary":"为什么需要 Monorepo 在开发中，功能模块间的耦合会导致项目难以维护，因此需要分包来进行解耦合。 但是单纯地进行分包，就需要单独发布，单独安装，会增加一些","title":"使用 pnpm 以 Monorepo 方式建立项目"},{"content":"Node.js 16 中加入了 corepack 工具，能够直接启用 pnpm 与 yarn 作为包管理器，而不需要通过 npm 进行额外的安装。\n尝试了在日常开发中使用 pnpm 与 yarn 替代 npm,记录了一些体验上的优化和实际使用中遇到的问题。\n通过 corepack 启用 pnpm 与 yarn corepack 目前还是实验性功能，需要按照文档1进行手动开启。\n 执行 corepack enable （如果 Node.js 未以 user 权限进行安装，需要 sudo 或 root 权限进行运行，windows 上需要以管理员模式运行） 配置 package.json 中的 packageManager （使用 pnpm 时即使不配置也可正常使用，使用 yarn 时如果不进行packageManager的配置，会使用 yarn 1 而非 yarn 2+） 如果需要在离线环境下启用，可以使用 corepack prepare 进行预载  pnpm 与 yarn 的优势 Phantom dependencies Phantom dependencies 是指依赖被安装后，非该依赖链上的代码也可以使用该依赖，例如\n// root { \u0026#34;dependencies\u0026#34;: { \u0026#34;a\u0026#34;: \u0026#34;^1.0.0\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;^1.0.0\u0026#34; } } // a { \u0026#34;dependencies\u0026#34;: { \u0026#34;b\u0026#34;: \u0026#34;^1.0.0\u0026#34; } } 安装后文件路径为\n/node_modules /a /b /c 其中 b 依赖可以被直接import/require，这造成了隐式依赖，可能出现不易发现的问题，详细说明可以参见 rushjs 的解释2。\nNPM doppelgangers NPM doppelgangers 是指同一依赖存在不同版本时，尽管 npm 进行了 hoist，仍会产生多个重复的依赖包，例如\n{ \u0026#34;dependencies\u0026#34;: { \u0026#34;a\u0026#34;: \u0026#34;^1.0.0\u0026#34;, =\u0026gt; { \u0026#34;e\u0026#34;: \u0026#34;^1.0.0\u0026#34; } \u0026#34;b\u0026#34;: \u0026#34;^1.0.0\u0026#34;, =\u0026gt; { \u0026#34;e\u0026#34;: \u0026#34;^1.0.0\u0026#34; } \u0026#34;c\u0026#34;: \u0026#34;^1.0.0\u0026#34;, =\u0026gt; { \u0026#34;e\u0026#34;: \u0026#34;^2.0.0\u0026#34; } \u0026#34;d\u0026#34;: \u0026#34;^1.0.0\u0026#34; =\u0026gt; { \u0026#34;e\u0026#34;: \u0026#34;^2.0.0\u0026#34; } } } 安装后文件路径为\n// npm 进行 hoist /node_modules /a /b /c /e@2 /d /e@2 /e@1 // 或 /node_modules /a /e@1 /b /e@1 /c /d /e@2 这样会导致重复依赖的存在不可避免，影响性能甚至会导致编译工具的一些 bug，详细说明可以参见 rushjs 的解释3。\npnpm 与 yarn 的优化 pnpm 采用 symlink 方式4，在项目中通过建立共享存储的 hardlink 来创建非平铺（non-flat）的 node_modules，从而避免了上述的问题，同时也减少了硬盘空间的占用。\nyarn (2+) 采用 Plug\u0026rsquo;n\u0026rsquo;Play 方式，通过一个 cjs 控制依赖的加载，以 zip 方式提供依赖，从而能够约束 phantom dependencies 问题，同时减少了硬盘的 IO。\n并且在这种方式下，将依赖 commit 进 git 成为可能，配合 yarn 的 zero install 功能，能够使项目更加稳健，不因依赖安装产生问题。\n使用中的一些问题 yarn 在遇到一些不很规范的包时，yarn PnP 会因为包调用 phantom dependencies 而出现依赖缺失，需要使用 loose 模式5绕过。\n同时，yarn PnP 会以 zip 格式安装依赖，需要额外安装 sdk 与相关插件等使编辑器能够正常工作，在一些受限环境下使用不友好。\npnpm 使用 hardlink 创建 non-flat 的 node_modules 有时候会导致文件读取问题。\n一个例子为，曾经遇到过在 Windows 10 环境下，通过 vite 运行依赖 @mui/icons-material 的应用时，出现 too many files 问题。\n临时的解决方案为使用\n// ok import { xxx } from \u0026#34;@mui/icons-material/XXX\u0026#34; 替代\n// error: too many files import { xxx } from \u0026#34;@mui/icons-material\u0026#34; 但这个问题在 Linux 下没能复现，不能确定是什么原因。并且由于手边没有能复现的环境，暂时也不能排查问题。\n总结 Node.js 增加 corepack 后，相信 yarn 与 pnpm 会被更为广泛地应用，从而解决一些 npm 一直存在的问题。\n从个人使用角度，yarn 与 pnpm 也确实提升了体验与开发效率，值得作为 Node.js 下主要的包管理工具。\n  https://nodejs.org/api/corepack.html#workflows\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://rushjs.io/pages/advanced/phantom_deps/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://rushjs.io/pages/advanced/npm_doppelgangers/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://pnpm.io/motivation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://yarnpkg.com/features/pnp#pnp-loose-mode\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/try.pnpm.and.yarn/","summary":"Node.js 16 中加入了 corepack 工具，能够直接启用 pnpm 与 yarn 作为包管理器，而不需要通过 npm 进行额外的安装。 尝试了在日常开发中使用 pnpm 与 yarn 替代 npm,记录了一些体验上的","title":"通过 corepack 使用 pnpm 与 yarn 作为包管理器"},{"content":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服务并未正常运行，执行systemctl --user status someService显示服务为active，并没有错误信息。重新尝试后仍然存在问题,客户端出现 502 Bad Gateway 错误，遂进行问题定位。\n定位问题 相关配置 因为仅是部分服务迁移到容器，原本的 Nginx 服务并没有变动，相关配置为\nlocation /somePath { proxy_redirect off; proxy_pass http://127.0.0.1:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $http_host; } 容器使用 Podman 在普通用户下运行，执行参数为\n-p 8000:3000 -v ./someDir/:/etc/some/config/:rw 服务本声也并没有变动，相关配置与数据也维持原样并进行映射。\n错误信息 客户端查看 log 后发现报错：\nFailed to dial to wss://someSite/somePath 502 Bad Gateway websocket: bad handshake 但没有额外信息，初步判断为 Nginx 无法连通子服务，从而产生 502 Bad Gateway 错误。\n问题排查  测试确认 Nginx 能够正常运行，其他路径下非容器内的服务都正常运行 在同参数下运行podman run busybox ls -al，确认配置文件与数据能被 container 正常获取 host 下直接连接 container 的 WebSocket，失败，显示 502 systemctl --user status显示 container 正常运行  于是缩小了问题范围，应该是容器化后的网络映射导致了问题。\n解决问题 查阅 podman 文档1,在 podman run 的文档中找到 --publish 与--network的说明。其中列出了网络模式：\n Valid mode values are:\n bridge[:OPTIONS,…]: Create a network stack on the default bridge. This is the default for rootfull containers. It is possible to specify these additional options: For example to set a static ipv4 address and a static mac address, use \u0026ndash;network bridge:ip=10.88.0.10,mac=44:33:22:11:00:99. [:OPTIONS,…]: Connect to a user-defined network; this is the network name or ID from a network created by podman network create. Using the network name implies the bridge network mode. It is possible to specify the same options described under the bridge mode above. You can use the \u0026ndash;network option multiple times to specify additional networks. none: Create a network namespace for the container but do not configure network interfaces for it, thus the container has no network connectivity. container:id: Reuse another container’s network stack. host: Do not create a network namespace, the container will use the host’s network. Note: The host mode gives the container full access to local system services such as D-bus and is therefore considered insecure. ns:path: Path to a network namespace to join. private: Create a new namespace for the container. This will use the bridge mode for rootfull containers and slirp4netns for rootless ones. slirp4netns[:OPTIONS,…]: use slirp4netns(1) to create a user network stack. This is the default for rootless containers. It is possible to specify these additional options:   并且检索后找到 stackoverflow 上的一个回答2，指出容器化会创建 network namespace，所以容器内部获取的 localhost 并非 host 下的 localhost，从而导致容器内服务不能正常运行。\n通过设置--net=host运行容器，或修改 Nginx 中proxy_pass的配置指向实际的 host 网络，就可以解决 502 的问题。\n一些延伸 使用--net=host参数是最简便的解决方法，但直接使用 host 网络会导致 port 冲突，造成多 container 场景下的部署问题。对容器网络进行配置的方式应该是更好的，但对于简单场景来说有些不必要，以后有机会也可以尝试一下。\n单机使用容器也是抱着尝试的心态，看看是否能简化服务的管理。使用过程中发现对容器相关的 cgroup、网络等问题还不够熟悉，就先记录下来，后续有时间时可以学习一下相关知识。\n  https://docs.podman.io/en/latest/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://stackoverflow.com/questions/38346847/nginx-docker-container-502-bad-gateway-response\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/container.websocket.502/","summary":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服","title":"端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误"},{"content":"前言 一次调试时，发现 Firefox 中可以通过 boolean 值来使用 Array.sort()，而在 Node.js 中仅能使用 number 类型。尽管这个问题没有造成代码错误，但还是会造成一些困惑。\nJS 引擎间差异 简单运行下测试代码，结果如下：\n Firefox  const arr = [{num:1}, {num:3}, {num:2}] const numSorted = arr.sort((a, b) =\u0026gt; a.num - b.num) console.log(numSorted) \u0026gt; Array [Object { num: 1 }, Object { num: 2 }, Object { num: 3 }] const arr = [{num:1}, {num:3}, {num:2}] const boolSorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(boolSorted) \u0026gt; Array [Object { num: 1 }, Object { num: 2 }, Object { num: 3 }]  Node.js  const arr = [{num:1}, {num:3}, {num:2}] const sorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(sorted) \u0026gt; [ { num: 1 }, { num: 3 }, { num: 2 } ]  Deno  const arr = [{num:1}, {num:3}, {num:2}] const sorted = arr.sort((a, b) =\u0026gt; a.num \u0026gt; b.num) console.log(sorted) \u0026gt; [ { num: 1 }, { num: 3 }, { num: 2 } ] 可以发现，Node 与 Deno 同样使用 V8 引擎，仅能在 Array.sort()中使用 number 类型作为判断，而 Firefox 中能够使用 number 或 boolean 值作为判断。\nTypeScript 中 Array.sort()的类型 在 TypeScript 中 Array.sort()的类型为\n(method) Array\u0026lt;T\u0026gt;.sort(compareFn?: ((a: T, b: T) =\u0026gt; number) | undefined): T[] 尝试使用 boolean 类型的 sort(),但 TS 报出类型错误:\nArgument of type \u0026#39;(a: { num: number; }, b: { num: number; }) =\u0026gt; boolean\u0026#39; is not assignable to parameter of type \u0026#39;(a: { num: number; }, b: { num: number; }) =\u0026gt; number\u0026#39;. Type \u0026#39;boolean\u0026#39; is not assignable to type \u0026#39;number\u0026#39;.ts(2345) MDN 文档与 ECMA 标准 查阅 MDN 文档1，\n So, the compare function has the following form:\nfunction compare(a, b) { if (a is less than b by some ordering criterion) { return -1; } if (a is greater than b by the ordering criterion) { return 1; } // a must be equal to b return 0; }  说明中并未标明可以使用 boolean 值，继续查阅 ECMA 文档2,\n  If x and y are both undefined, return +0𝔽. If x is undefined, return 1𝔽. If y is undefined, return -1𝔽. If comparefn is not undefined, then  Let v be ? ToNumber(? Call(comparefn, undefined, « x, y »)). If v is NaN, return +0𝔽. Return v.   Let xString be ? ToString(x). Let yString be ? ToString(y). Let xSmaller be ! IsLessThan(xString, yString, true). If xSmaller is true, return -1𝔽. Let ySmaller be ! IsLessThan(yString, xString, true). If ySmaller is true, return 1𝔽. Return +0𝔽.   标准中同样也未指出可以使用 boolean 值进行判断。\n总结 Firefox 中能够使用 boolean 值进行判断，可能是 Firefox 的实现问题，在相关文档与标准中并没有相关说明。实际写代码时，在 lint 工具等约束后应该并不会产生异常问题，仅是出于好奇进行了一些检索，简单记录一下。\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.sort\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jasondg.github.io/posts/firefox.sort.by.boolean/","summary":"前言 一次调试时，发现 Firefox 中可以通过 boolean 值来使用 Array.sort()，而在 Node.js 中仅能使用 number 类型。尽管这个问题没有造成代码错误，但还是会造成一些困","title":"Firefox 中 Array.sort() 能够使用 boolean 值进行判断"},{"content":"Hello world 突然萌生了一个念头，想着可以写写博客，简单地记录一点平时的所见所思。\n近来看过的东西不少，积累下来的却不多。博客也就权当是备忘录了，写一写，记一记，兴许能多积累些。即便没什么获益，以后再看，也算是一些回忆了。\n以此自勉。\n","permalink":"https://jasondg.github.io/posts/0/","summary":"\u003ch1 id=\"hello-world\"\u003eHello world\u003c/h1\u003e","title":"0"}]