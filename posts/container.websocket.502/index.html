<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误 | JasonDG</title><meta name=keywords content="container,websocket,proxy,Podman,Nginx"><meta name=description content="前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服"><meta name=author content><link rel=canonical href=https://jasondg.github.io/posts/container.websocket.502/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jasondg.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasondg.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasondg.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jasondg.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jasondg.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://jasondg.github.io/posts/container.websocket.502/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误"><meta property="og:description" content="前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服"><meta property="og:type" content="article"><meta property="og:url" content="https://jasondg.github.io/posts/container.websocket.502/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-30T19:59:15+08:00"><meta property="article:modified_time" content="2022-04-23T21:42:18+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误"><meta name=twitter:description content="前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasondg.github.io/posts/"},{"@type":"ListItem","position":2,"name":"端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误","item":"https://jasondg.github.io/posts/container.websocket.502/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误","name":"端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误","description":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服","keywords":["container","websocket","proxy","Podman","Nginx"],"articleBody":"前言 前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服务并未正常运行，执行systemctl --user status someService显示服务为active，并没有错误信息。重新尝试后仍然存在问题,客户端出现 502 Bad Gateway 错误，遂进行问题定位。\n定位问题 相关配置 因为仅是部分服务迁移到容器，原本的 Nginx 服务并没有变动，相关配置为\nlocation /somePath { proxy_redirect off; proxy_pass http://127.0.0.1:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; } 容器使用 Podman 在普通用户下运行，执行参数为\n-p 8000:3000 -v ./someDir/:/etc/some/config/:rw 服务本声也并没有变动，相关配置与数据也维持原样并进行映射。\n错误信息 客户端查看 log 后发现报错：\nFailed to dial to wss://someSite/somePath 502 Bad Gateway websocket: bad handshake 但没有额外信息，初步判断为 Nginx 无法连通子服务，从而产生 502 Bad Gateway 错误。\n问题排查  测试确认 Nginx 能够正常运行，其他路径下非容器内的服务都正常运行 在同参数下运行podman run busybox ls -al，确认配置文件与数据能被 container 正常获取 host 下直接连接 container 的 WebSocket，失败，显示 502 systemctl --user status显示 container 正常运行  于是缩小了问题范围，应该是容器化后的网络映射导致了问题。\n解决问题 查阅 podman 文档1,在 podman run 的文档中找到 --publish 与--network的说明。其中列出了网络模式：\n Valid mode values are:\n bridge[:OPTIONS,…]: Create a network stack on the default bridge. This is the default for rootfull containers. It is possible to specify these additional options: For example to set a static ipv4 address and a static mac address, use –network bridge:ip=10.88.0.10,mac=44:33:22:11:00:99. [:OPTIONS,…]: Connect to a user-defined network; this is the network name or ID from a network created by podman network create. Using the network name implies the bridge network mode. It is possible to specify the same options described under the bridge mode above. You can use the –network option multiple times to specify additional networks. none: Create a network namespace for the container but do not configure network interfaces for it, thus the container has no network connectivity. container:id: Reuse another container’s network stack. host: Do not create a network namespace, the container will use the host’s network. Note: The host mode gives the container full access to local system services such as D-bus and is therefore considered insecure. ns:path: Path to a network namespace to join. private: Create a new namespace for the container. This will use the bridge mode for rootfull containers and slirp4netns for rootless ones. slirp4netns[:OPTIONS,…]: use slirp4netns(1) to create a user network stack. This is the default for rootless containers. It is possible to specify these additional options:   并且检索后找到 stackoverflow 上的一个回答2，指出容器化会创建 network namespace，所以容器内部获取的 localhost 并非 host 下的 localhost，从而导致容器内服务不能正常运行。\n通过设置--net=host运行容器，或修改 Nginx 中proxy_pass的配置指向实际的 host 网络，就可以解决 502 的问题。\n一些延伸 使用--net=host参数是最简便的解决方法，但直接使用 host 网络会导致 port 冲突，造成多 container 场景下的部署问题。对容器网络进行配置的方式应该是更好的，但对于简单场景来说有些不必要，以后有机会也可以尝试一下。\n单机使用容器也是抱着尝试的心态，看看是否能简化服务的管理。使用过程中发现对容器相关的 cgroup、网络等问题还不够熟悉，就先记录下来，后续有时间时可以学习一下相关知识。\n  https://docs.podman.io/en/latest/ ↩︎\n https://stackoverflow.com/questions/38346847/nginx-docker-container-502-bad-gateway-response ↩︎\n   ","wordCount":"1110","inLanguage":"zh","datePublished":"2022-03-30T19:59:15+08:00","dateModified":"2022-04-23T21:42:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jasondg.github.io/posts/container.websocket.502/"},"publisher":{"@type":"Organization","name":"JasonDG","logo":{"@type":"ImageObject","url":"https://jasondg.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasondg.github.io/ accesskey=h title="JasonDG (Alt + H)">JasonDG</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jasondg.github.io/en/ title=English aria-label=English>English</a></li></ul></span></div><ul id=menu><li><a href=https://jasondg.github.io/archives/ title=文章><span>文章</span></a></li><li><a href=https://jasondg.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://jasondg.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://jasondg.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>端口映射后容器内 WebSocket 产生 502 Bad Gateway 错误</h1><div class=post-meta><span title="2022-03-30 19:59:15 +0800 +0800">三月 30, 2022</span>&nbsp;·&nbsp;3 分钟</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%ae%9a%e4%bd%8d%e9%97%ae%e9%a2%98 aria-label=定位问题>定位问题</a><ul><li><a href=#%e7%9b%b8%e5%85%b3%e9%85%8d%e7%bd%ae aria-label=相关配置>相关配置</a></li><li><a href=#%e9%94%99%e8%af%af%e4%bf%a1%e6%81%af aria-label=错误信息>错误信息</a></li><li><a href=#%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5 aria-label=问题排查>问题排查</a></li></ul></li><li><a href=#%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98 aria-label=解决问题>解决问题</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e5%bb%b6%e4%bc%b8 aria-label=一些延伸>一些延伸</a></li></ul></div></details></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>前段时间试着把一些老服务升级了一下，有一些也移进了容器里，用 Podman 跑 rootless container。因为外层的 Nginx 没有动，本以为能快速迁移，但启动 container 后服务并未正常运行，执行<code>systemctl --user status someService</code>显示服务为<code>active</code>，并没有错误信息。重新尝试后仍然存在问题,客户端出现 <code>502 Bad Gateway</code> 错误，遂进行问题定位。</p><h1 id=定位问题>定位问题<a hidden class=anchor aria-hidden=true href=#定位问题>#</a></h1><h2 id=相关配置>相关配置<a hidden class=anchor aria-hidden=true href=#相关配置>#</a></h2><p>因为仅是部分服务迁移到容器，原本的 Nginx 服务并没有变动，相关配置为</p><pre tabindex=0><code>location /somePath {
    proxy_redirect off;
    proxy_pass http://127.0.0.1:8000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &#34;upgrade&#34;;
    proxy_set_header Host $http_host;
}
</code></pre><p>容器使用 Podman 在普通用户下运行，执行参数为</p><pre tabindex=0><code>-p 8000:3000
-v ./someDir/:/etc/some/config/:rw
</code></pre><p>服务本声也并没有变动，相关配置与数据也维持原样并进行映射。</p><h2 id=错误信息>错误信息<a hidden class=anchor aria-hidden=true href=#错误信息>#</a></h2><p>客户端查看 log 后发现报错：</p><pre tabindex=0><code>Failed to dial to wss://someSite/somePath
502 Bad Gateway
websocket: bad handshake
</code></pre><p>但没有额外信息，初步判断为 Nginx 无法连通子服务，从而产生 502 Bad Gateway 错误。</p><h2 id=问题排查>问题排查<a hidden class=anchor aria-hidden=true href=#问题排查>#</a></h2><ul><li>测试确认 Nginx 能够正常运行，其他路径下非容器内的服务都正常运行</li><li>在同参数下运行<code>podman run busybox ls -al</code>，确认配置文件与数据能被 container 正常获取</li><li>host 下直接连接 container 的 WebSocket，失败，显示 502</li><li><code>systemctl --user status</code>显示 container 正常运行</li></ul><p>于是缩小了问题范围，应该是容器化后的网络映射导致了问题。</p><h1 id=解决问题>解决问题<a hidden class=anchor aria-hidden=true href=#解决问题>#</a></h1><p>查阅 podman 文档<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>,在 <a href=https://docs.podman.io/en/latest/markdown/podman-run.1.html>podman run</a> 的文档中找到 <a href=https://docs.podman.io/en/latest/markdown/podman-run.1.html#publish-p-ip-hostport-containerport-ip-containerport-hostport-containerport-containerport><code>--publish</code></a> 与<a href=https://docs.podman.io/en/latest/markdown/podman-run.1.html#network-mode-net><code>--network</code></a>的说明。其中列出了网络模式：</p><blockquote><p>Valid mode values are:</p><ul><li><em>bridge[:OPTIONS,…]</em>: Create a network stack on the default bridge. This is the default for rootfull containers. It is possible to specify these additional options:
For example to set a static ipv4 address and a static mac address, use &ndash;network bridge:ip=10.88.0.10,mac=44:33:22:11:00:99.</li><li><em>[:OPTIONS,…]</em>: Connect to a user-defined network; this is the network name or ID from a network created by podman network create. Using the network name implies the bridge network mode. It is possible to specify the same options described under the bridge mode above. You can use the &ndash;network option multiple times to specify additional networks.</li><li><em>none</em>: Create a network namespace for the container but do not configure network interfaces for it, thus the container has no network connectivity.</li><li><em>container:id</em>: Reuse another container’s network stack.</li><li><em>host</em>: Do not create a network namespace, the container will use the host’s network. Note: The host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.</li><li><em>ns:path:</em> Path to a network namespace to join.</li><li><em>private</em>: Create a new namespace for the container. This will use the bridge mode for rootfull containers and slirp4netns for rootless ones.</li><li><em>slirp4netns[:OPTIONS,…]</em>: use slirp4netns(1) to create a user network stack. This is the default for rootless containers. It is possible to specify these additional options:</li></ul></blockquote><p>并且检索后找到 stackoverflow 上的一个回答<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，指出容器化会创建 network namespace，所以容器内部获取的 localhost 并非 host 下的 localhost，从而导致容器内服务不能正常运行。</p><p>通过设置<code>--net=host</code>运行容器，或修改 Nginx 中<code>proxy_pass</code>的配置指向实际的 host 网络，就可以解决 502 的问题。</p><h1 id=一些延伸>一些延伸<a hidden class=anchor aria-hidden=true href=#一些延伸>#</a></h1><p>使用<code>--net=host</code>参数是最简便的解决方法，但直接使用 host 网络会导致 port 冲突，造成多 container 场景下的部署问题。对容器网络进行配置的方式应该是更好的，但对于简单场景来说有些不必要，以后有机会也可以尝试一下。</p><p>单机使用容器也是抱着尝试的心态，看看是否能简化服务的管理。使用过程中发现对容器相关的 cgroup、网络等问题还不够熟悉，就先记录下来，后续有时间时可以学习一下相关知识。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.podman.io/en/latest/>https://docs.podman.io/en/latest/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://stackoverflow.com/questions/38346847/nginx-docker-container-502-bad-gateway-response>https://stackoverflow.com/questions/38346847/nginx-docker-container-502-bad-gateway-response</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jasondg.github.io/tags/container/>container</a></li><li><a href=https://jasondg.github.io/tags/websocket/>websocket</a></li><li><a href=https://jasondg.github.io/tags/proxy/>proxy</a></li><li><a href=https://jasondg.github.io/tags/podman/>Podman</a></li><li><a href=https://jasondg.github.io/tags/nginx/>Nginx</a></li></ul><nav class=paginav><a class=prev href=https://jasondg.github.io/posts/try.pnpm.and.yarn/><span class=title>« 上一页</span><br><span>通过 corepack 使用 pnpm 与 yarn 作为包管理器</span></a>
<a class=next href=https://jasondg.github.io/posts/firefox.sort.by.boolean/><span class=title>下一页 »</span><br><span>Firefox 中 Array.sort() 能够使用 boolean 值进行判断</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://jasondg.github.io/>JasonDG</a></span>
&bull;
<span>使用 <a href=http://creativecommons.org/licenses/by-sa/4.0 target=_blank>CC BY-SA 4.0</a> 许可</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>